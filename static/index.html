<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WordAncestry</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root {
      --border: #ddd;
      --bg: #fafafa;
      --card: #fff;
      --text: #111;
      --muted: #666;
    }
  
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color: var(--text); }
  
    header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    header .title { font-weight: 700; }
    header input {
      flex: 1 1 220px;
      min-width: 180px;
      font-size: 16px;              /* 16px avoids iOS zoom-on-focus */
      padding: 10px 12px;
    }
    header button {
      font-size: 14px;
      padding: 10px 12px;
      cursor: pointer;
      flex: 0 0 auto;
    }
  
    .layout {
      display: grid;
      grid-template-columns: 1fr 360px;
      height: calc(100vh - 58px);
      min-height: 0;
    }
  
    #map { width: 100%; height: 100%; }
  
    .side {
      border-left: 1px solid var(--border);
      overflow: auto;
      padding: 12px;
      background: var(--bg);
      -webkit-overflow-scrolling: touch;
    }
  
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 12px; overflow: hidden; }
    .card .bar { padding: 10px 12px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #eee; gap: 8px; }
    .card .bar .q { font-weight: 650; overflow:hidden; text-overflow: ellipsis; white-space: nowrap; }
    .card .bar button { font-size: 12px; padding: 7px 9px; }
  
    .path { padding: 8px 12px; }
    .item {
      padding: 10px 12px;
      border: 1px solid #eee;
      border-radius: 12px;
      margin: 10px 0;
      cursor: pointer;
      touch-action: manipulation;
    }
    .item:hover { border-color: #bbb; }
    .item.active { border-color: #111; box-shadow: 0 0 0 2px rgba(0,0,0,0.08) inset; }
    .item .lang { font-weight: 650; }
    .item .word { color:#444; word-break: break-word; }
  
    .hint { color: var(--muted); font-size: 12px; padding: 0 12px 10px; }
  
    /* --- Mobile / small screens --- */
    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr 320px;
      }
    }
  
    @media (max-width: 768px) {
      header { gap: 10px; }
      header .title { width: 100%; }
  
      .layout {
        grid-template-columns: 1fr;
        grid-template-rows: 58vh 42vh; /* map on top, list below */
        height: calc(100vh - 58px);
      }
  
      .side {
        border-left: none;
        border-top: 1px solid var(--border);
        padding: 10px 12px;
      }
    }
  
    @media (max-width: 420px) {
      header { padding: 10px 12px; }
      header input { flex-basis: 100%; }
      header button { width: 100%; }
    }
  </style>

</head>
<body>

<header>
  <div class="title">WordAncestry</div>
  <input id="wordInput" placeholder="Type a word (e.g., salary) and press Enter" />
  <button id="goBtn">Add</button>
</header>

<div class="layout">
  <div id="map"></div>
  <div class="side" id="side"></div>
</div>

<script>
  // ----- Map setup -----
  const map = L.map("map", { preferCanvas: true }).setView([20, 0], 2);
  // Ensure Leaflet re-renders correctly when layout changes (mobile rotation, etc.)
  function fixMapSizeSoon() {
    setTimeout(() => map.invalidateSize(), 150);
  }
  window.addEventListener("resize", fixMapSizeSoon);
  window.addEventListener("orientationchange", fixMapSizeSoon);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);

  // Layers per query card
  const state = {
    cards: [], // {query, graph, selectedNodeId, layers: {markers, polylines}}
    activeCardIndex: null
  };

  function clearMapLayers(card) {
    if (!card.layers) return;
    card.layers.markers.forEach(m => map.removeLayer(m));
    card.layers.polylines.forEach(l => map.removeLayer(l));
  }

  function renderCardLayers(card) {
    clearMapLayers(card);
    const markers = [];
    const polylines = [];

    const nodesById = new Map(card.graph.nodes.map(n => [n.id, n]));
    const latlngs = [];

    // Draw edges
    for (const e of card.graph.edges) {
      const a = nodesById.get(e.source);
      const b = nodesById.get(e.target);
      if (!a || !b) continue;
      const A = [a.location.lat, a.location.lon];
      const B = [b.location.lat, b.location.lon];
      latlngs.push(A, B);

      const isActiveEdge = (card.selectedNodeId && (e.source === card.selectedNodeId || e.target === card.selectedNodeId));
      const poly = L.polyline([A, B], {
        weight: isActiveEdge ? 4 : 2,
        opacity: isActiveEdge ? 0.9 : 0.6
      }).addTo(map);
      polylines.push(poly);
    }

    // Draw nodes
    for (const n of card.graph.nodes) {
      const isActive = (n.id === card.selectedNodeId);
      const marker = L.circleMarker([n.location.lat, n.location.lon], {
        radius: isActive ? 9 : 6,
        weight: isActive ? 3 : 2,
        opacity: 0.9,
        fillOpacity: 0.8
      }).addTo(map);

      marker.bindTooltip(`${n.language}: ${n.word}`, {sticky: true});
      marker.on("click", () => selectNode(card.query, n.id));
      markers.push(marker);
      latlngs.push([n.location.lat, n.location.lon]);
    }

    card.layers = { markers, polylines };

    // Fit view (only when first created)
    if (latlngs.length && card._fitOnce !== true) {
      card._fitOnce = true;
      const bounds = L.latLngBounds(latlngs);
      map.fitBounds(bounds.pad(0.25));
    }
  }

  function selectNode(query, nodeId) {
    const idx = state.cards.findIndex(c => c.query === query);
    if (idx < 0) return;
    state.activeCardIndex = idx;
    state.cards[idx].selectedNodeId = nodeId;
    render();
  }

  // ----- UI rendering -----
  function render() {
    const side = document.getElementById("side");
    side.innerHTML = "";

    if (state.cards.length === 0) {
      const p = document.createElement("div");
      p.className = "hint";
      p.textContent = "Add a word to see its lineage (right) and language hops on the map (left).";
      side.appendChild(p);
      return;
    }

    state.cards.forEach((card, i) => {
      // Update map layers for this card only if active, otherwise keep it faint or skip.
      // v1 behavior: show only active card on the map.
      if (state.activeCardIndex === null) state.activeCardIndex = 0;

      const isActiveCard = (i === state.activeCardIndex);

      if (isActiveCard) {
        renderCardLayers(card);
      } else {
        clearMapLayers(card);
      }

      const c = document.createElement("div");
      c.className = "card";

      const bar = document.createElement("div");
      bar.className = "bar";

      const q = document.createElement("div");
      q.className = "q";
      q.textContent = card.query;

      const btn = document.createElement("button");
      btn.textContent = isActiveCard ? "Active" : "Make active";
      btn.onclick = () => { state.activeCardIndex = i; render(); };

      bar.appendChild(q);
      bar.appendChild(btn);

      const path = document.createElement("div");
      path.className = "path";

      const nodesById = new Map(card.graph.nodes.map(n => [n.id, n]));
      card.graph.primary_path.forEach((nid, j) => {
        const n = nodesById.get(nid);
        if (!n) return;

        const item = document.createElement("div");
        item.className = "item" + (card.selectedNodeId === nid ? " active" : "");
        item.onclick = () => selectNode(card.query, nid);

        const lang = document.createElement("div");
        lang.className = "lang";
        lang.textContent = `(${String.fromCharCode(97 + j)}) ${n.language}`;

        const wd = document.createElement("div");
        wd.className = "word";
        wd.textContent = n.word;

        item.appendChild(lang);
        item.appendChild(wd);
        path.appendChild(item);
      });

      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = "Click a stage to highlight it on the map.";

      c.appendChild(bar);
      c.appendChild(path);
      c.appendChild(hint);

      side.appendChild(c);
    });
  }

  // ----- Query handling -----
  async function addWord(word) {
    const w = (word || "").trim();
    if (!w) return;

    const res = await fetch(`/api/etymology?word=${encodeURIComponent(w)}`);
    if (!res.ok) {
      alert(`Failed to fetch etymology for "${w}"`);
      return;
    }
    const graph = await res.json();

    const card = {
      query: graph.query,
      graph,
      selectedNodeId: graph.primary_path?.[0] || null,
      layers: null,
      _fitOnce: false
    };

    // clear any existing map layers/cards
    state.cards.forEach(c => clearMapLayers(c));
    
    // keep ONLY the latest word
    state.cards = [card];
    state.activeCardIndex = 0;
    render();

  }

  document.getElementById("goBtn").onclick = () => addWord(document.getElementById("wordInput").value);
  document.getElementById("wordInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter") addWord(e.target.value);
  });

  render();
</script>

</body>
</html>

